/// <reference path="./index.d.ts" />
import{contractPrincipalCV as S}from"https://deno.land/x/microstacks/clarity.js";var A="ST000000000000000000002AMW42H",_="SP000000000000000000002Q6VF78",y=(t,e)=>{let n=typeof t=="string"?t:String(t),[a,...r]=n.replace("!","").replace("?","").split("-"),s=e?`${a[0].toUpperCase()}${a.slice(1)}`:a;return r.forEach(l=>{s+=l[0].toUpperCase()+l.slice(1)}),s},O=t=>{let e=t.split("/"),n=e[e.length-1],[a]=n.split(".");return a},pt=t=>`${t.address}.${t.name}`,ut=t=>{let e=O(t.contractFile);return S(t.address,e)};function ft(t,e){return`${e?_:A}.${t}`}var w=(i=>(i.ContractEvent="contract_event",i.StxTransferEvent="stx_transfer_event",i.StxMintEvent="stx_mint_event",i.StxBurnEvent="stx_burn_event",i.StxLockEvent="stx_lock_event",i.NftTransferEvent="nft_transfer_event",i.NftMintEvent="nft_mint_event",i.NftBurnEvent="nft_burn_event",i.FtTransferEvent="ft_transfer_event",i.FtMintEvent="ft_mint_event",i.FtBurnEvent="ft_burn_event",i))(w||{});function dt(t,e){return t.filter(n=>n.type===e)}function yt(t,e={}){let n={};for(let a in t){let r=t[a],s=e.deployerAddress||r.address,l=`${s}.${r.name}`,p=r.contract(s,r.name);n[a]={identifier:l,contract:p}}return n}import{addressToString as v,ClarityType as o,uintCV as R,contractPrincipalCV as V,intCV as B,stringAsciiCV as F,stringUtf8CV as I,noneCV as P,someCV as h,tupleCV as M,listCV as $,hexToCV as U,bufferCV as j}from"https://deno.land/x/microstacks/clarity.js";import{isClarityAbiList as L,isClarityAbiOptional as H,isClarityAbiStringAscii as K,isClarityAbiStringUtf8 as G,isClarityAbiTuple as D,isClarityAbiBuffer as J,parseToCV as x}from"https://deno.land/x/microstacks/transactions.js";import{bytesToAscii as z,bytesToHex as Q}from"https://deno.land/x/microstacks/common.js";function W(t){return{isOk:!0,value:t}}function q(t){return{isOk:!1,value:t}}function T(t){if(t.type===o.PrincipalStandard)return v(t.address);if(t.type===o.PrincipalContract)return`${v(t.address)}.${t.contractName.content}`;throw new Error(`Unexpected principal data: ${JSON.stringify(t)}`)}function c(t,e=!1){switch(t.type){case o.BoolTrue:return!0;case o.BoolFalse:return!1;case o.Int:case o.UInt:return t.value;case o.Buffer:return t.buffer;case o.OptionalNone:return null;case o.OptionalSome:return c(t.value);case o.ResponseErr:return e?q(c(t.value)):c(t.value);case o.ResponseOk:return e?W(c(t.value)):c(t.value);case o.PrincipalStandard:case o.PrincipalContract:return T(t);case o.List:return t.list.map(r=>c(r));case o.Tuple:let n={};return Object.keys(t.data).map(r=>[r,c(t.data[r])]).forEach(([r,s])=>{n[r]=s}),n;case o.StringASCII:return t.data;case o.StringUTF8:return t.data}}function _t(t,e=!1){return c(U(t),e)}function E(t){if(!(typeof t=="bigint"||typeof t=="number"||typeof t=="string"))throw new Error("Invalid input type for integer");return BigInt(t)}function d(t,e){if(D(e)){if(typeof t!="object")throw new Error("Invalid tuple input");let n={};return e.tuple.forEach(a=>{let r=t[a.name];n[a.name]=d(r,a.type)}),M(n)}else if(L(e)){let a=t.map(r=>d(r,e.list.type));return $(a)}else{if(H(e))return t?h(d(t,e.optional)):P();if(K(e)){if(typeof t!="string")throw new Error("Invalid string-ascii input");return F(t)}else if(G(e)){if(typeof t!="string")throw new Error("Invalid string-ascii input");return I(t)}else if(e==="bool"){let n=typeof t=="boolean"?t.toString():t;return x(n,e)}else if(e==="uint128"){let n=E(t);return R(n.toString())}else if(e==="int128"){let n=E(t);return B(n.toString())}else if(e==="trait_reference"){if(typeof t!="string")throw new Error("Invalid input for trait_reference");let[n,a]=t.split(".");return V(n,a)}else if(J(e))return j(t)}return x(t,e)}function C(t,e="hex"){switch(t.type){case o.BoolTrue:return"true";case o.BoolFalse:return"false";case o.Int:return t.value.toString();case o.UInt:return`u${t.value.toString()}`;case o.Buffer:if(e==="tryAscii"){let n=z(t.buffer);if(/[ -~]/.test(n))return JSON.stringify(n)}return`0x${Q(t.buffer)}`;case o.OptionalNone:return"none";case o.OptionalSome:return`(some ${C(t.value,e)})`;case o.ResponseErr:return`(err ${C(t.value,e)})`;case o.ResponseOk:return`(ok ${C(t.value,e)})`;case o.PrincipalStandard:case o.PrincipalContract:return`'${T(t)}`;case o.List:return`(list ${t.list.map(n=>C(n,e)).join(" ")})`;case o.Tuple:return`(tuple ${Object.keys(t.data).map(n=>`(${n} ${C(t.data[n],e)})`).join(" ")})`;case o.StringASCII:return`"${t.data}"`;case o.StringUTF8:return`u"${t.data}"`}}function m(t,e){return e.map((n,a)=>d(n,t.args[a].type))}function g(t){if(t.isOk)return t.value;throw new Error(`Expected OK, received error: ${t.value}`)}function N(t){if(!t.isOk)return t.value;throw new Error(`Expected Err, received ok: ${t.value}`)}function X(t,e){return m(t,e)}function Y(t,e){let n=t.abi.functions.find(r=>y(r.name)===e);if(n)return function(...r){return{functionArgs:X(n,r),contractAddress:t.contractAddress,contractName:t.contractName,function:n,nativeArgs:r}};let a=t.abi.maps.find(r=>y(r.name)===e);if(a)return r=>{let s=d(r,a.key);return{contractAddress:t.contractAddress,contractName:t.contractName,map:a,nativeKey:r,key:s}};throw new Error(`Invalid function call: no function exists for ${String(e)}`)}var Z={get:Y},tt=t=>new Proxy(t,Z);import{parseReadOnlyResponse as et,fetchContractDataMapEntry as nt}from"https://deno.land/x/microstacks/api.js";import{cvToHex as k,hexToCV as rt}from"https://deno.land/x/microstacks/clarity.js";import{fetchPrivate as ot}from"https://deno.land/x/microstacks/common.js";import{broadcastTransaction as at}from"https://deno.land/x/microstacks/transactions.js";async function b(t,e){let a=`${e.network.getReadOnlyFunctionCallApiUrl(t.contractAddress,t.contractName,t.function.name)}?tip=latest`,r=JSON.stringify({sender:t.contractAddress,arguments:t.functionArgs.map(p=>typeof p=="string"?p:k(p))}),s=await ot(a,{method:"POST",body:r,headers:{"Content-Type":"application/json"}});if(!s.ok){let p="";try{p=await s.text()}catch{}throw new Error(`Error calling read-only function. Response ${s.status}: ${s.statusText}. Attempted to fetch ${a} and failed with the message: "${p}"`)}let l=et(await s.json());return c(l,!0)}async function Kt(t,e){let n=await b(t,e);return g(n)}async function Gt(t,e){let n=await b(t,e);return N(n)}async function Dt(t,e){let n=k(t.key),a=await nt({contract_address:t.contractAddress,contract_name:t.contractName,map_name:t.map.name,lookup_key:n,tip:"latest",url:e.network.getCoreApiUrl(),proof:0}),r=rt(a.data);return c(r,!0)}async function Jt(t,e){let n=await at(t,e.network);if("error"in n)throw new Error(`Error broadcasting tx: ${n.error} - ${n.reason} - ${n.reason_data}`);return{txId:n.txid,stacksTransaction:t}}export{w as CoreNodeEventType,_ as MAINNET_BURN_ADDRESS,A as TESTNET_BURN_ADDRESS,ft as bootContractIdentifier,Jt as broadcast,C as cvToString,c as cvToValue,q as err,N as expectErr,g as expectOk,Dt as fetchMapGet,dt as filterEvents,pt as getContractIdentifier,O as getContractNameFromPath,ut as getContractPrincipalCV,_t as hexToCvValue,yt as makeContracts,W as ok,d as parseToCV,tt as pureProxy,b as ro,Gt as roErr,Kt as roOk,y as toCamelCase,m as transformArgsToCV};
